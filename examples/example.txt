main: () -> void {
    let s1: Student = Student {
        name = "Alice",
        hwScore = 0.95,
        testScore = 0.85,
    };

    let s2: Student = {
        name = "Bob",
        hwScore = 0.8,
        testScore = 0.9,
    };

    let avg: f32 = Student.avgScore([s1, s2]);
}

struct Student {
    name: [char];
    hwScore: f32;
    testScore: f32;

    score: () -> f32 {
        return (0.3 * hwScore) + (0.7 * testScore);
    }
}

namespace Student {
    avgScore: (students: [Student]) -> f32 {
        total: f32 = 0.0;
        for student in students {
            total += student.score();
        }
        return total / students.length;
    }
}





id opColon opLParen opRParen opArrow typeVoid opLBrace
    kwLet id opColon id opEquals opLBrace
        id opEquals litStr opComma
        id opEquals litFloat opComma
        id opEquals litFloat opComma
    opRBrace opSemicolon

    kwLet id opColon typeF32 opEquals id opDot id opLParen opLBracket id
        id opComma id
    opRBracket opRParen opSemicolon
opRBrace

kwStruct id opLBrace
    id opColon opLBracket typeChar opRBracket opSemicolon
    id opColon typeF32 opSemicolon
    id opColon typeF32 opSemicolon

    id opColon opLParen opRParen opArrow typeF32 opLBrace
        kwReturn opLParen litFloat opStar id opRParen
            opPlus opLParen litFloat opStar id opRParen opSemicolon
    opRBrace
opRBrace

kwNamespace id opLBrace
    id opColon opLParen id opColon opLBracket id opRBracket opRParen
            opArrow typeF32 opLBrace
        id opColon typeF32 opEquals litFloat opSemicolon
        kwFor id kwIn id opLBrace
            id opPlusEq id opDot id opLBrace opRBrace opSemicolon
        opRBrace
        kwReturn id opSlash id opDot kwLength opSemicolon
    opRBrace
opRBrace
