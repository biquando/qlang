$(abc) => S1(a) -> S2(b) -> S3(c)

$([abc]) => S1(abc)

$(A|B) => $(A) | $(B)

$(A*) => $(A)*

abc[def] => $(abc)$([def])

$(C(A|B)D) => $(C) -> ( $(A) | $(B) ) -> $(D)




\"([^\\\n]|\\.)*\"
CONCAT {
    CONCAT {
        \"                      S4
        REPEAT {
            ALTERNATE {
                [^\\\n]         S3
                CONCAT {
                    \\          S1
                    .           S2
                }
            }
        }
    }
    \"                          S5
}


E(a) = a
X(a) = a

E(AB) = E(A)
X(AB) = X(B)

E(A+) = E(A)
X(A+) = X(A)

E(A*) = E(A) U E(\0)
X(A*) = X(A) U X(\0)

E(A|B) = E(A) U E(B)
X(A|B) = X(A) U X(B)

Observations:
- A literal can be either a character /a/ or choice of characters /[abc]/
- All incoming edges for a given state have the same literal
- There is an isomorphism between literals and states (sans epsilons)
- The character set for an epsilon state is the union of all successors


State {
    literal
    list of successors
    void addEdge(const State &other) {
        successors.push_back(&other)
    }
    State *transition(char c) {
        State *next = nullptr
        for State *other in successors {
            if other->matches(c) {
                next = other
                break
            }
        }
        if next->literal is epsilon {
            next = next->transition(c)
        }
        return next
    }
    bool matches(char c) {
        if literal is character {
            return c == literal
        }
        if literal is [] {
            return c in []
        }
        if literal is epsilon {
            for State *other in successors {
                if other->matches(c) {
                    return true
                }
            }
            return false
        }
    }
}

StateGroup {
    set of states
    set of entry states
    set of exit states
}

Node {
    virtual StateGroup sg() = 0;
    virtual void connect() = 0;
}
LiteralNode : Node {
    void connect() {}
}
ConcatNode : Node {
    StateGroup sg() {
        return {
            .states = left.states + right.states
            .entry  = left.entry
            .exit   = right.exit
        }
    }
    void connect() {
        for l in left.exit {
            for r in right.entry {
                l --> r
            }
        }
    }
}
AlternateNode : Node {
    StateGroup sg() {
        return {
            .states = left.states + right.states
            .entry  = left.entry  + right.entry
            .exit   = left.exit   + right.exit
        }
    }
    void connect() {}
}
PlusNode : Node {
    StateGroup sg() {
        return {
            .states = left.states
            .entry  = left.entry
            .exit   = left.exit
        }
    }
    void connect() {
        for e in left.entry {
            for x in left.exit {
                x --> e
            }
        }
    }
}
StarNode : Node {
    StateGroup sg() {
        return {
            .states = left.states + {Epsilon}
            .entry  = left.entry  + {Epsilon}
            .exit   = left.exit   + {Epsilon}
        }
    }
    void connect() {
        for e in left.entry {
            for x in left.exit {
                x --> e
            }
        }
    }
}



char(a) = [a]
entry(a) = [a] |-> state(a)
exit(a) = state(a)

char(a) = [abc]
entry([abc]) = [abc] |-> state([abc])
exit([abc]) = state([abc])

char(AB) = char(A)
entry(AB) = char(A) |-> entry(A)
exit(AB) = exit(B)

char(A*) = char(A)
entry(A*) = char(A) |-> entry(A)
exit(A*) = exit(A)

entry(A|B) = { char(A) |-> entry(A), char(B) |-> entry(B) }




# Parsing regex

1. tokenize
2. validate
3. decompose

validation:
- nonempty
- matching () and []
- alternation has something on each side
- on the left side of alternation: literal or -)].*+
- on the right side of alternation: literal or -([.
- plus/star comes after a literal or -)].
- valid ranges for -'-' in []
    - for each -'-' at idx i
        - check for literals at i-1 and i+1
        - check that i+2 is not -'-'
    - don't need to check that -'-' are only in [] because the tokenizer takes
      care of that, and [] are checked to be matched earlier

precedence:
- plus/star
- concat
- alternation

decomposition:
- if everything is wrapped in ()
    - unwrap recursively
    - to check for this, check that the depth is only zero at the beginning/end
- check for alternation
    - if there is a -'|' outside of parentheses
- check for concatenation
    - depth := 0
    - nPieces := 0
    - for each char c
        - if c == -'('
            - depth++
        - if c == -')'
            - depth--
        - if depth == 0
            - nPieces++
        - if nPieces > 1
            - return true // this also gives us the boundary between pieces
- check for plus/star
    - if the last char is a -plus/star
- check for charchoice
    - first char is -'['
- check for char
    - assert the only char is a literal or -'.'
